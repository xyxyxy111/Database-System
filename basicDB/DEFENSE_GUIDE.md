# MiniDB 答辩指导文档

> 面向《大型平台软件设计实习》课程答辩使用（最后更新：2025-09-16）

---
## 1. 3~5 分钟口述稿（演讲提纲）
（无需逐字背诵，围绕逻辑即可）

大家好，我的项目是一个教学型、可扩展的关系数据库原型 MiniDB，目标是在适中代码体量内实现完整的 SQL → 编译 → 执行 → 存储 → 事务 → 统计的系统链路，并保持良好的可观测性与演进空间。

整体架构采用分层设计：最上层是 SQL 编译管道（词法、语法、语义分析加执行计划生成与规则优化），中间是查询执行与事务/聚合/优化器/诊断辅助组件，底层是页式存储 + 缓存管理 + 磁盘持久化。通过 AST 与 Execution Plan 这两个稳定的中间表示，实现上层语义到下层物理访问的解耦。

核心功能包括：DDL（CREATE TABLE）、DML（INSERT/SELECT/UPDATE/DELETE）、JOIN、ORDER BY、聚合函数（COUNT、SUM、AVG、MAX、MIN、DISTINCT），以及基础事务（BEGIN/COMMIT/ROLLBACK）、规则查询优化（谓词下推、常量折叠、表达式简化）、多缓存策略（LRU/FIFO/CLOCK/LFU）、持久化与性能/优化统计输出。语义检查覆盖表/列存在性、列数与类型匹配，并对典型语法与拼写类错误给出结构化诊断信息。

设计理念是“最小内核 + 清晰边界 + 可演进性”：1）AST/Plan 作为协议边界，便于未来加索引或成本优化器；2）存储层对执行层屏蔽页面结构；3）事务、聚合、优化、诊断均为可插拔组件；4）测试脚本与调试工具链支撑快速验证。亮点在于：不仅能运行 SQL，还能可视化计划、验证优化效果、比较缓存策略、展示事务回滚一致性与统计报表。

演示建议：展示一条有语法问题的 SQL 的诊断 → 展示一条查询的 Token / AST / 原始计划 / 优化后计划 → 执行含过滤 + JOIN + 聚合 + 排序的查询 → 切换缓存策略对比命中率 → 演示事务回滚 → 输出优化与性能统计。最后说明已预留索引、WAL、MVCC、分布式等扩展接口。项目验证了数据库内核“结构化 + 可解释 + 可扩展”的工程路径。谢谢。

---
## 2. 可能被问到的问题与示范回答

### 2.1 架构与设计
**问：为什么拆成词法 / 语法 / 语义三个阶段？**  
答：职责分离，降低耦合；便于单独测试；语义错误不与语法纠缠；符合数据库前端经典管线模型，利于后续插入优化阶段。

**问：AST 与执行计划的区别是什么？**  
答：AST 贴近语言结构（SELECT 的各子句语义保持）；执行计划强调数据流与算子节点（Project(Filter(SeqScan ...)))），便于优化与物理映射。

**问：为什么执行计划采用通用节点树结构？**  
答：统一接口可序列化、便于调试与规则重写，也为未来成本估算、统计信息接入留出空间。

**问：选择 JSON 记录存储的原因？缺点？**  
答：教学直观、开发迭代快；缺点是空间浪费、解析成本高、缺乏紧凑类型布局。未来可换二进制行布局或列式编码。

**问：多缓存策略的意义？**  
答：对比实验 + 验证抽象层可插拔性；展示系统层面性能差异，增强教学价值。

### 2.2 语义与扩展
**问：如何新增 GROUP BY?**  
答：Parser 加语法 → AST 增 Group 表示 → 语义添加聚合列合法性检查 → Plan 插入 Group/Aggregate 算子 → 执行层实现分组聚合逻辑 → 优化器可加聚合下推或合并规则。

**问：如何接入 B+ 树索引？**  
答：新增索引元数据结构（Catalog 扩展），设计索引页类型，维护插入/删除同步；执行计划加 IndexScan 节点；优化器基于谓词选择走索引。

**问：查询优化现状与局限？**  
答：当前为基于规则：谓词下推、常量折叠、表达式简化、冗余条件清理；缺少成本模型与统计信息，尚未做 Join Reorder 等高级优化。

### 2.3 执行与性能
**问：JOIN 使用什么算法？**  
答：实现了嵌套循环，清晰直观；未来可替换或扩展 Hash Join、Index Nested Loop。节点抽象不需要重写整体框架。

**问：ORDER BY 如何实现？**  
答：当前收集结果后内存排序；未来数据量大时可扩展为外部排序或分块多路归并。

**问：聚合是如何实现的？**  
答：扫描记录累积中间状态（COUNT/SUM/...），支持 DISTINCT（通过集合或去重结构），再输出单行或若干聚合列结果。未做分组聚合（Group Aggregation），可扩展。

**问：能否流式执行（pipeline）？**  
答：目前算子是“拉取”式逐行处理；未实现批向量化与算子融合；可在接口上扩展 next_batch() 以支持向量化处理提升缓存局部性。

### 2.4 事务与一致性
**问：事务如何回滚？**  
答：对写操作记录 undo 信息（旧记录或位置），ROLLBACK 时逆序恢复。采用串行执行，未实现并发隔离与日志持久化（无 WAL）。

**问：为何未先做 WAL？**  
答：教学优先级：先确保端到端正确数据流；WAL 需刷盘顺序、崩溃恢复协议与 LSN 管理，工程复杂度更高，放在后续阶段实现。

**问：未来实现 MVCC 的路径？**  
答：在记录层增加版本链（指向旧版本），在 Catalog 或事务管理器维护活跃事务 ID，可基于时间戳或事务 ID 做可见性判断；计划节点保持不变。

### 2.5 错误与诊断
**问：错误诊断如何避免“误纠正”？**  
答：先确定语法失败点，再根据 FIRST/FOLLOW 集、Token 相似度（如大小写/单字符缺失）生成有限候选，策略保守：提示而不篡改输入。

**问：如果用户输入 SELECT * FROM (users 缺右括号？**  
答：Parser 在期望右括号时遇到 EOF，抛出带行列 + 期望符号的 ParseError，诊断模块可再包装提示“可能缺少 ) 或子查询不完整”。

### 2.6 性能与统计
**问：性能统计有哪些指标？**  
答：查询总数、平均执行时间、慢查询列表、优化应用次数/类型分布、缓存命中率、淘汰次数等；用于展示系统可观测性。

**问：优化前后如何展示差异？**  
答：打印执行计划的 JSON/树形表示；例如 `age > 20 + 5 AND age > 25` → 常量折叠 + 冗余谓词合并后只保留 `age > 25`。

### 2.7 边界与未来
**问：当前最大限制是什么？**  
答：无索引、无并发控制、无崩溃恢复、无成本优化；适合教学与功能演示，但不适合生产场景。结构上已留扩展点。

**问：下一步最具性价比的增强？**  
答：B+ 树索引 (显著提升点查/范围查询)、统计信息收集 + 成本优化框架、WAL + 崩溃恢复，提高可靠性与性能基础。 

---
## 3. 演示节奏与时间分配建议（5 分钟基准）
| 时间 | 环节 | 操作要点 | 输出/亮点 |
|------|------|----------|-----------|
| 0:00 - 0:40 | 背景 & 目标 | 说明“端到端 + 可观测 + 可扩展” | 价值定位明确 |
| 0:40 - 1:30 | 架构 | 展示架构图（编译→执行→存储→事务/优化） | 结构清晰 |
| 1:30 - 2:20 | 功能 & 亮点 | 列核心 SQL 支持、优化、缓存策略、事务 | 底座扎实 |
| 2:20 - 3:30 | 动态演示 | 语法诊断→计划前后→复合查询→缓存策略→事务回滚 | 可视化 & 说服力 |
| 3:30 - 4:20 | 设计理念 | 解耦/协议/可演进/测试体系 | 工程思维 |
| 4:20 - 5:00 | 规划 & 总结 | 索引/WAL/MVCC/分布式预留 | 可持续性 |

可增加“对比优化前后计划”作为加分点：打印两棵树或 JSON。

---
## 4. 推荐演示脚本片段
```sql
-- 1) 语法诊断示例
SELET * FROM users;  -- 触发诊断

-- 2) 基本建表 + 数据
CREATE TABLE users (id INT, name VARCHAR(50), age INT);
INSERT INTO users VALUES (1,'Alice',25);
INSERT INTO users VALUES (2,'Bob',30);

-- 3) 优化前后（常量折叠）
SELECT * FROM users WHERE age > 20 + 5 AND age > 25;

-- 4) JOIN + 聚合 + 排序（示意，可按已有表）
-- 假设已有 orders(user_id INT, amount INT)
SELECT u.name, SUM(o.amount) 
FROM users u JOIN orders o ON u.id = o.user_id 
WHERE o.amount > 100 
ORDER BY u.name;

-- 5) 事务回滚
BEGIN;
INSERT INTO users VALUES (3,'Temp',99);
ROLLBACK;
SELECT * FROM users; -- 验证未生效
```

---
## 5. 亮点复述（速记版）
- 分层 + 中间表示（AST/Plan）
- 可插拔：优化器 / 缓存策略 / 事务管理
- 规则优化 + 计划可视化
- 多缓存策略统计对比
- 基本事务 + Undo 回滚
- 聚合、排序、JOIN、UPDATE 协同
- 错误诊断增强 & 性能/优化报告
- 面向未来：索引 / WAL / MVCC / 分布式已预留入口

---
## 6. 未来演进路线（一句话版）
1. 索引 + 统计信息 → 成本优化器基础  
2. WAL + 崩溃恢复 → 可靠性  
3. MVCC + 并发控制 → 多用户隔离  
4. 分布式（分片 + 复制 + 协调）→ 水平扩展  

---
## 7. 快速答辩前自检 Checklist
- [ ] 架构图（是否准备好展示版本）
- [ ] 计划树打印函数可正常输出
- [ ] 缓存策略切换接口准备好（示例参数）
- [ ] 演示脚本中的数据库文件清理逻辑（防旧数据干扰）
- [ ] 事务回滚演示前确认初始行数
- [ ] 优化报告、性能报告输出格式演练

---
## 8. 精简 60 秒版本（备用）
本项目实现了一个教学型可扩展关系数据库 MiniDB，覆盖 SQL 编译、查询优化、算子执行、事务控制、页式存储与多缓存策略，并支持 JOIN / ORDER BY / 聚合 / UPDATE。通过 AST 与执行计划解耦编译与执行，缓存层支持 LRU/FIFO/CLOCK/LFU 对比，优化器可做谓词下推与常量折叠。提供性能与优化统计、错误诊断增强与事务回滚。架构已为索引、WAL、MVCC、分布式预留扩展点，体现“最小内核 + 可演进”设计理念。该系统有效展示了数据库内核的关键路径与工程可观测性。

---
**祝答辩顺利！**
